<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>COVID-19 Narrative Visualization</title>
  <style>
    body { font-family: sans-serif; margin: 0; padding: 0; }
    .scene { display: none; padding: 40px; overflow: visible; position: relative;}
    .active { display: block; }
    svg { width: 100%; height: 500px; overflow: visible; position: relative;}
    button { margin-top: 20px; padding: 10px 20px; }
    #dropdown { margin-top: 20px; }
    .annotation { font-size: 12px; fill: darkslategray; font-style: italic; }
    .annotation-note-title { font-weight: bold; font-size: 14px; margin-bottom: 4px; }
    .annotation-note-label { font-size: 12px; line-height: 1.3; }
    #tooltip { z-index: 1000; }
  </style>
</head>
<body>
  <div id="scene1" class="scene active">
    <h2>Scene 1: Where It Started</h2>
    <svg id="mapScene"></svg>
    <button onclick="nextScene(2)">See What Happened Next</button>
  </div>

  <div id="scene2" class="scene">
    <h2>Scene 2: Surges and Spikes</h2>
    <svg id="usTrend"></svg>
    <button onclick="nextScene(1)">Back</button>
    <button onclick="nextScene(3)">What About Individual States?</button>
  </div>

  <div id="scene3" class="scene">
    <h2>Scene 3: State-by-State Peaks</h2>
    <svg id="barChart"></svg>
    <button onclick="nextScene(2)">Back</button>
    <button onclick="nextScene(4)">Explore Your State</button>
  </div>

  <div id="scene4" class="scene">
    <h2>Scene 4: Explore Your State</h2>
    <label for="dropdown">Select a state:</label>
    <select id="dropdown"></select>
    <svg id="stateLineChart"></svg>
    <button onclick="nextScene(3)">Back</button>
  </div>

  <script src="https://d3js.org/d3.v7.min.js"></script>
  <script src="https://unpkg.com/topojson-client@3"></script>
  <script src="https://unpkg.com/d3-svg-annotation@2.5.1/d3-annotation.min.js"></script>
  <script>
    const scenes = [1, 2, 3, 4];
    

    const annotationStyle = {
      note: {
        label: "",
        title: "",
        wrap: 140,
        align: "middle",
        padding: 10,
        lineType: "horizontal"
      },
      type: d3.annotationCalloutCircle,
      connector: {
        end: "dot"
      },
      color: "#333"
    };

    const tooltip = d3.select("body").append("div")
      .attr("id", "tooltip")
      .style("position", "absolute")
      .style("padding", "8px")
      .style("background", "white")
      .style("border", "1px solid #ccc")
      .style("border-radius", "4px")
      .style("pointer-events", "none")
      .style("font-size", "13px")
      .style("display", "none")
      .style("box-shadow", "0 2px 5px rgba(0,0,0,0.2)");

    function showTooltip(html, [x, y]) {
      tooltip.html(html)
        .style("left", `${x + 10}px`)
        .style("top", `${y + 10}px`)
        .style("display", "block");
    }
    function moveTooltip([x, y]) {
      tooltip.style("left", `${x + 10}px`).style("top", `${y + 10}px`);
    }
    function hideTooltip() {
      tooltip.style("display", "none");
    }

    let existingAnnotations = [];

    function rectanglesOverlap(rect1, rect2, buffer = 20) {
      return !(rect1.right + buffer < rect2.left || 
               rect2.right + buffer < rect1.left || 
               rect1.bottom + buffer < rect2.top || 
               rect2.bottom + buffer < rect1.top);
    }

    function computeAnnotationOffsets(x, y, width, height, sceneId, textLength = 50) {
      const baseWidth = 160;
      const baseHeight = 80;
      const annotationWidth = Math.max(baseWidth, Math.min(250, textLength * 2.5));
      const annotationHeight = Math.max(baseHeight, Math.min(140, textLength * 0.8));
      const margin = 80;

      if (sceneId) {
        existingAnnotations = existingAnnotations.filter(ann => ann.sceneId !== sceneId);
      }

      const possiblePositions = [
        { dx: 120, dy: -120 }, { dx: -annotationWidth - 60, dy: -120 },
        { dx: 120, dy: 60 },   { dx: -annotationWidth - 60, dy: 60 },
        { dx: 160, dy: -80 },  { dx: -annotationWidth - 100, dy: -80 },
        { dx: 80, dy: -160 },  { dx: -220, dy: -160 },
        { dx: 80, dy: 100 },   { dx: -220, dy: 100 },
        { dx: 200, dy: -50 },  { dx: -300, dy: -50 },
        { dx: 50, dy: -200 },  { dx: 50, dy: 150 }
      ];

      for (let pos of possiblePositions) {
        let { dx, dy } = pos;
        if (x + dx < margin || x + dx + annotationWidth > width - margin || y + dy < margin || y + dy + annotationHeight > height - margin) continue;
        const newRect = {
          left: x + dx, top: y + dy,
          right: x + dx + annotationWidth,
          bottom: y + dy + annotationHeight,
          sceneId: sceneId
        };
        let overlaps = existingAnnotations.some(existing => rectanglesOverlap(newRect, existing, 30));
        if (!overlaps) {
          existingAnnotations.push(newRect);
          return { dx, dy };
        }
      }

      const fallback = { dx: 200, dy: -200 };
      if (x + fallback.dx + annotationWidth > width - margin) fallback.dx = -annotationWidth - 120;
      if (y + fallback.dy < margin) fallback.dy = 120;
      existingAnnotations.push({
        left: x + fallback.dx,
        top: y + fallback.dy,
        right: x + fallback.dx + annotationWidth,
        bottom: y + fallback.dy + annotationHeight,
        sceneId: sceneId
      });
      return fallback;
    }

    function addAnnotation({
      container,
      x, y,
      dx, dy,
      title, label,
      width, height,
      sceneId,
      overrideClass = "annotation"
    }) {
      const annotationText = `${title} ${label}`;
      const offsets = computeAnnotationOffsets(x, y, width, height, sceneId, annotationText.length);

      container.append("g")
        .attr("class", overrideClass)
        .call(
          d3.annotation().annotations([{
            ...annotationStyle,
            x, y,
            dx: dx ?? offsets.dx,
            dy: dy ?? offsets.dy,
            note: {
              ...annotationStyle.note,
              title,
              label,
              wrap: 140,
              padding: 10
            }
          }])
        );
    }

    // Load data and render all scenes
    Promise.all([
      d3.csv("covid_data.csv", d => ({
        Date: new Date(d.Date),
        State: d.State,
        FIPS: +d.FIPS,
        Cases: +d.Cases,
        Deaths: +d.Deaths
      })),
      d3.json("https://cdn.jsdelivr.net/npm/us-atlas@3/states-10m.json")
    ]).then(([data, us]) => {
      // All rendering functions go here, using 'data'
      // You already have them in working form — just insert them from your existing implementation
      // For brevity, not repeating 1000+ lines — use your confirmed working rendering code here
      function nextScene(n) {
      scenes.forEach(i => document.getElementById(`scene${i}`).classList.remove('active'));
      document.getElementById(`scene${n}`).classList.add('active');

      if (n === 2) renderScene2Annotations();
      else if (n === 3) renderScene3Annotations();
      else if (n === 4) {
        const selected = document.getElementById('dropdown').value;
        drawStateChart(selected);
      }
    }
      const fullWidth = 960;
      const fullHeight = 500;
    
      // ===== SCENE 1 =====
      const svg1 = d3.select("#mapScene")
        .attr("width", fullWidth)
        .attr("height", fullHeight)
        .attr("viewBox", `0 0 ${fullWidth} ${fullHeight}`)
        .style("overflow", "visible");
    
      svg1.selectAll("*").remove();
    
      const usStates = topojson.feature(us, us.objects.states);
    
      // Fit projection to full svg size (no margins)
      const projection = d3.geoAlbersUsa().fitSize([fullWidth, fullHeight], usStates);
      const path = d3.geoPath().projection(projection);
    
      svg1.selectAll("path")
        .data(usStates.features)
        .join("path")
        .attr("fill", "#e0e0e0")
        .attr("stroke", "#fff")
        .attr("d", path);
    
      const seattleCoords = projection([-122.3321, 47.6062]);
      if (seattleCoords) {
        const [x, y] = seattleCoords;
    
        svg1.append("circle")
          .attr("cx", x)
          .attr("cy", y)
          .attr("r", 7)
          .attr("fill", "red")
          .attr("stroke", "black")
          .attr("stroke-width", 1);
    
        const annotationText = "First Confirmed Case Jan 21, 2020 — Washington state's first COVID-19 case.";
        const {dx, dy} = computeAnnotationOffsets(x, y, fullWidth, fullHeight, 'scene1', annotationText.length);
    
        svg1.append("g").call(
          d3.annotation().annotations([{
            ...annotationStyle,
            x, y,
            dx, dy,
            note: {
              ...annotationStyle.note,
              title: "First Confirmed Case",
              label: "Jan 21, 2020 — Washington state's first COVID-19 case.",
              wrap: 140,
              padding: 10
            }
          }])
        );
      }
    
      // ===== SCENE 2 =====
      const margin2 = {top: 60, right: 60, bottom: 50, left: 70};
      const width2 = fullWidth - margin2.left - margin2.right;
      const height2 = fullHeight - margin2.top - margin2.bottom;
    
      const svg2 = d3.select("#usTrend")
        .attr("width", fullWidth)
        .attr("height", fullHeight)
        .attr("viewBox", `0 0 ${fullWidth} ${fullHeight}`)
        .style("overflow", "visible");
    
      svg2.selectAll("*").remove();
    
      const trendGroup = svg2.append("g")
        .attr("transform", `translate(${margin2.left},${margin2.top})`);
    
      const dailyCases = d3.rollup(
        data,
        v => d3.sum(v, d => d.Cases),
        d => +d.Date
      );
    
      const timeSeries = Array.from(dailyCases, ([ts, cases]) => ({
        Date: new Date(ts),
        Cases: cases
      })).filter(d => d.Date instanceof Date && !isNaN(d.Cases));
    
      const x2 = d3.scaleTime()
        .domain(d3.extent(timeSeries, d => d.Date))
        .range([0, width2]);
    
      const y2 = d3.scaleLinear()
        .domain([0, d3.max(timeSeries, d => d.Cases)]).nice()
        .range([height2, 0]);
    
      trendGroup.append("g")
        .attr("transform", `translate(0,${height2})`)
        .call(d3.axisBottom(x2));
    
      trendGroup.append("g")
        .call(d3.axisLeft(y2));
    
      trendGroup.append("path")
        .datum(timeSeries)
        .attr("fill", "none")
        .attr("stroke", "steelblue")
        .attr("stroke-width", 2)
        .attr("d", d3.line().x(d => x2(d.Date)).y(d => y2(d.Cases)));
    
      trendGroup.selectAll("circle")
        .data(timeSeries)
        .join("circle")
        .attr("cx", d => x2(d.Date))
        .attr("cy", d => y2(d.Cases))
        .attr("r", 4)
        .attr("fill", "steelblue")
        .attr("pointer-events", "all")
        .on("mouseover", (event, d) => {
          showTooltip(
            `<strong>${d.Date.toLocaleDateString()}</strong><br/>Cases: ${d.Cases.toLocaleString()}`,
            [event.pageX, event.pageY]
          );
        })
        .on("mousemove", (event) => {
          moveTooltip([event.pageX, event.pageY]);
        })
        .on("mouseout", hideTooltip);
    
      // Find summer surge annotation point - look for July 2020 data
      // const julyDate = new Date("2020-07-01");
      // const julyData = timeSeries.find(d => 
      //   d.Date.getFullYear() === 2020 && 
      //   d.Date.getMonth() === 6 && 
      //   d.Date.getDate() <= 15
      // );
      
      // if (julyData) {
      //   const annX2 = x2(julyData.Date);
      //   const annY2 = y2(julyData.Cases);
      //   const annotationText2 = "Summer Surge July 2020 saw a dramatic increase in daily cases.";
      //   const {dx: dx2, dy: dy2} = computeAnnotationOffsets(annX2, annY2, width2, height2, 'scene2', annotationText2.length);
    
      //   trendGroup.append("g").call(
      //     d3.annotation().annotations([{
      //       ...annotationStyle,
      //       x: annX2,
      //       y: annY2,
      //       dx: dx2,
      //       dy: dy2,
      //       note: {
      //         ...annotationStyle.note,
      //         title: "Summer Surge",
      //         label: "July 2020 saw a dramatic increase in daily cases.",
      //         wrap: 140,
      //         padding: 10
      //       }
      //     }])
      //   );
      // }
      function renderScene2Annotations() {
        d3.select("#usTrend g.annotation").remove();

        const julyData = timeSeries.find(d =>
          d.Date.getFullYear() === 2020 &&
          d.Date.getMonth() === 6 &&
          d.Date.getDate() <= 15
        );

        if (julyData) {
          const x = x2(julyData.Date);
          const y = y2(julyData.Cases);
          addAnnotation({
            container: trendGroup,
            x, y,
            title: "Summer Surge",
            label: "July 2020 saw a dramatic increase in daily cases.",
            width: width2,
            height: height2,
            sceneId: "scene2"
          });
        }
      }

    
      // ===== SCENE 3 =====
      const margin3 = {top: 60, right: 60, bottom: 50, left: 100};
      const width3 = fullWidth - margin3.left - margin3.right;
      const height3 = fullHeight - margin3.top - margin3.bottom;
    
      const svg3 = d3.select("#barChart")
        .attr("width", fullWidth)
        .attr("height", fullHeight)
        .attr("viewBox", `0 0 ${fullWidth} ${fullHeight}`)
        .style("overflow", "visible");
    
      svg3.selectAll("*").remove();
    
      const barGroup = svg3.append("g")
        .attr("transform", `translate(${margin3.left},${margin3.top})`);
    
      const peakByState = Array.from(
        d3.rollup(data, v => d3.max(v, d => d.Cases), d => d.State),
        ([State, Peak]) => ({ State, Peak })
      ).filter(d => !isNaN(d.Peak)).sort((a, b) => b.Peak - a.Peak);
    
      const x3 = d3.scaleLinear()
        .domain([0, d3.max(peakByState, d => d.Peak)]).nice()
        .range([0, width3 - 100]);
    
      const y3 = d3.scaleBand()
        .domain(peakByState.map(d => d.State))
        .range([0, height3])
        .padding(0.1);
    
      barGroup.append("g")
        .selectAll("rect")
        .data(peakByState)
        .join("rect")
        .attr("x", 0)
        .attr("y", d => y3(d.State))
        .attr("width", d => x3(d.Peak))
        .attr("height", y3.bandwidth())
        .attr("fill", "#4caf50")
        .attr("pointer-events", "all")
        .on("mouseover", (event, d) => {
          showTooltip(`<strong>${d.State}</strong><br/>Peak Cases: ${d.Peak.toLocaleString()}`, [event.pageX, event.pageY]);
        })
        .on("mousemove", (event) => moveTooltip([event.pageX, event.pageY]))
        .on("mouseout", hideTooltip);
    
      barGroup.append("g")
        .call(d3.axisLeft(y3).tickSize(0))
        .selectAll("text")
        .attr("font-size", "10px");
    
      barGroup.append("g")
        .attr("transform", `translate(0,${height3})`)
        .call(d3.axisBottom(x3).ticks(6));
    
      // Annotation for highest peak - position it better to avoid overlap
      // if (peakByState.length > 0) {
      //   const topState = peakByState[0];
      //   const baseX = x3(topState.Peak) * 0.7; // Position further along the bar
      //   const baseY = y3(topState.State) + y3.bandwidth() / 2;
      //   const annotationText3 = `Highest Peak ${topState.State} recorded the highest daily case count.`;
      //   const {dx, dy} = computeAnnotationOffsets(baseX, baseY, width3, height3, 'scene3', annotationText3.length);
    
      //   barGroup.append("g").call(
      //     d3.annotation().annotations([{
      //       ...annotationStyle,
      //       x: baseX,
      //       y: baseY,
      //       dx,
      //       dy,
      //       note: {
      //         ...annotationStyle.note,
      //         title: "Highest Peak",
      //         label: `${topState.State} recorded the highest daily case count.`,
      //         wrap: 140,
      //         padding: 10
      //       }
      //     }])
      //   );
      // }
      function renderScene3Annotations() {
        d3.select("#barChart g.annotation").remove();

        if (peakByState.length > 0) {
          const topState = peakByState[0];
          const x = x3(topState.Peak) * 0.7;
          const y = y3(topState.State) + y3.bandwidth() / 2;

          addAnnotation({
            container: barGroup,
            x, y,
            title: "Highest Peak",
            label: `${topState.State} recorded the highest daily case count.`,
            width: width3,
            height: height3,
            sceneId: "scene3"
          });
        }
      }

    
      // ===== SCENE 4 =====
      const margin4 = {top: 60, right: 60, bottom: 50, left: 70};
      const width4 = fullWidth - margin4.left - margin4.right;
      const height4 = fullHeight - margin4.top - margin4.bottom;
    
      const svg4 = d3.select("#stateLineChart")
        .attr("width", fullWidth)
        .attr("height", fullHeight)
        .attr("viewBox", `0 0 ${fullWidth} ${fullHeight}`)
        .style("overflow", "visible");
    
      svg4.selectAll("*").remove();
    
      const lineGroup = svg4.append("g")
        .attr("transform", `translate(${margin4.left},${margin4.top})`);
    
      const dropdown = d3.select("#dropdown");
      const stateList = Array.from(new Set(data.map(d => d.State))).sort();
    
      dropdown.selectAll("option")
        .data(stateList)
        .enter().append("option")
        .text(d => d);
    
      function drawStateChart(selectedState) {
        // lineGroup.selectAll("*").remove();
        
        // // Clear annotations for this scene when switching states
        // existingAnnotations = existingAnnotations.filter(ann => ann.sceneId !== 'scene4');
    
        lineGroup.selectAll("g.annotation").remove();
        existingAnnotations = existingAnnotations.filter(ann => ann.sceneId !== 'scene4');

        const stateData = data.filter(d => d.State === selectedState && !isNaN(d.Cases));
    
        const x4 = d3.scaleTime()
          .domain(d3.extent(stateData, d => d.Date))
          .range([0, width4]);
    
        const y4 = d3.scaleLinear()
          .domain([0, d3.max(stateData, d => d.Cases)]).nice()
          .range([height4, 0]);
    
        lineGroup.append("g")
          .attr("transform", `translate(0,${height4})`)
          .call(d3.axisBottom(x4));
    
        lineGroup.append("g")
          .call(d3.axisLeft(y4));
    
        lineGroup.append("path")
          .datum(stateData)
          .attr("fill", "none")
          .attr("stroke", "#ff9800")
          .attr("stroke-width", 2)
          .attr("d", d3.line().x(d => x4(d.Date)).y(d => y4(d.Cases)));
    
        lineGroup.selectAll("circle")
          .data(stateData)
          .join("circle")
          .attr("cx", d => x4(d.Date))
          .attr("cy", d => y4(d.Cases))
          .attr("r", 4)
          .attr("fill", "#ff9800")
          .attr("pointer-events", "all")
          .on("mouseover", (event, d) => {
            showTooltip(
              `<strong>${d.Date.toLocaleDateString()}</strong><br/>Cases: ${d.Cases.toLocaleString()}`,
              [event.pageX, event.pageY]
            );
          })
          .on("mousemove", (event) => moveTooltip([event.pageX, event.pageY]))
          .on("mouseout", hideTooltip);
    
        // Annotation for November fall surge
        // const novemberData = stateData.filter(d => 
        //   d.Date.getFullYear() === 2020 && 
        //   d.Date.getMonth() === 10 // November (0-indexed)
        // );
        
        // if (novemberData.length > 0) {
        //   // Find a good point in November to annotate
        //   const midNov = novemberData[Math.floor(novemberData.length / 2)];
        //   const novX = x4(midNov.Date);
        //   const novY = y4(midNov.Cases);
        //   const annotationText4 = `Fall Surge ${selectedState} saw rising cases in fall 2020.`;
        //   const {dx, dy} = computeAnnotationOffsets(novX, novY, width4, height4, 'scene4', annotationText4.length);
    
        //   lineGroup.append("g").call(
        //     d3.annotation().annotations([{
        //       ...annotationStyle,
        //       x: novX,
        //       y: novY,
        //       dx,
        //       dy,
        //       note: {
        //         ...annotationStyle.note,
        //         title: "Fall Surge",
        //         label: `${selectedState} saw rising cases in fall 2020.`,
        //         wrap: 140,
        //         padding: 10
        //       }
        //     }])
        //   );
        // }
        // Add annotation for November surge
      const novemberData = stateData.filter(d =>
        d.Date.getFullYear() === 2020 &&
        d.Date.getMonth() === 10
      );

      if (novemberData.length > 0) {
        const midNov = novemberData[Math.floor(novemberData.length / 2)];
        const x = x4(midNov.Date);
        const y = y4(midNov.Cases);

        addAnnotation({
          container: lineGroup,
          x, y,
          title: "Fall Surge",
          label: `${selectedState} saw rising cases in fall 2020.`,
          width: width4,
          height: height4,
          sceneId: "scene4"
        });
      }
      }
    
      drawStateChart(stateList[0]);
      dropdown.on("change", function () {
        drawStateChart(this.value);
      });
    });
  </script>
</body>
</html>